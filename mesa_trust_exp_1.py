# -*- coding: utf-8 -*-
"""mesa-trust-exp-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZoaCQ1jPE3Dg1rWZ6qf3z-_ZLsdenb3C
"""

pip install mesa[rec]

from mesa import Agent, Model
import math
import numpy as np
import matplotlib.pyplot as plt



class PlayerA(Agent):
    @staticmethod
    def softmax(x):
      e_x = np.exp(x)
      return e_x / e_x.sum()
    def __init__(self, unique_id, model, initial_money=6, strategy=None):
        super().__init__(model)   # Mesa 3.x: pass model only
        self.unique_id = unique_id

        self.money = initial_money
        self.amount_sent = 0
        self.strategy = strategy
        self.phi_wealth=[("give",0.95),("give",0.9),("give",0.85),("give",0.8),("give",0.75),("give",0.7),("give",0.65),("give",0.6),("give",0.55),("give",0.5),("give",0.45),("give",0.4),("give",0.35),("give",0.3),("give",0.25),("give",0.2),("give",0.15),("give",0.1),("give",0.05),]
        #self.phi_gratitude=[("give",0.55),("give",0.50),("give",0.45),("give",0.4),("give",0.38),("give",0.36),("give",0.34),("give",0.32),("give",0.30),("give",0.28),("give",0.24),("give",0.22),("give",0.20),("give",0.18),("give",0.16),("give",0.14),("give",0.12),("give",0.1),("give",0.05)]
        #self.phi_wealth=[("give",0.55),("give",0.50),("give",0.45),("give",0.4),("give",0.38),("give",0.36),("give",0.34),("give",0.32),("give",0.30),("give",0.28),("give",0.24),("give",0.22),("give",0.20),("give",0.18),("give",0.16),("give",0.14),("give",0.12),("give",0.1),("give",0.05)]
        #self.phi_wealth=[("give",0.25),("give",0.23),("give",0.21),("give",0.19),("give",0.18),("give",0.17),("give",0.16),("give",0.15),("give",0.15),("give",0.14),("give",0.13),("give",0.12),("give",0.11),("give",0.10),("give",0.09),("give",0.08),("give",0.07),("give",0.06),("give",0.05)]

        self.phi_gratitude=[("give",0.0),("give",0.1),("give",0.2),("give",0.3),("give",0.4),("give",0.5),("give",0.6),("give",0.65),("give",0.7),("give",0.72),("give",0.74),("give",0.76),("give",0.78),("give",0.8),("give",0.81),("give",0.82),("give",0.83),("give",0.84),("give",0.85),]
        self.integrity_threshold = 0.1


    def benevolence_calculation(self,benevolence_wealth,benevolence_gratitude,given):

        print("benevolence wealth: ", benevolence_wealth)
        print("benevolence gratitude: ", benevolence_gratitude)
        #benevolence_wealth = 0.5
        #benevolence_gratitude = 0.5
        benevolence_V=[]
        for task in range(len(self.phi_wealth)):
            phi_w = self.phi_wealth[task][1]
            #print("phi_w: ", phi_w)
            phi_init_w=self.phi_wealth[0][1]
            phi_init_r=self.phi_gratitude[0][1]
            phi_r = self.phi_gratitude[task][1]
            #print("phi_r= ", phi_r)
            if (((benevolence_wealth+phi_w)-phi_init_w)>0 and task <= 3*given):
                sur_wealth = ((benevolence_wealth+phi_w)-phi_init_w)
            else:
                sur_wealth = 0
            if (((benevolence_gratitude+phi_r)-phi_init_r )>0 and task <= 3*given):
                sur_gratitude = ((benevolence_gratitude+phi_r)-phi_init_r)
            else:
                sur_gratitude = 0
            if sur_wealth<=0 or sur_gratitude<=0:
                ben=0
            else:
                ben = math.sqrt(sur_wealth**2 + sur_gratitude**2)
            benevolence_V.append(ben)
        print("benevolence V")
        print(benevolence_V)
        return benevolence_V

    def integrity_calculation(self):
        principle_wealth = 0.5
        principle_gratitude = 0.5
        initial_plan = 0
        bs_wealth = self.phi_wealth[initial_plan][1]
        bs_gratitude = self.phi_gratitude[initial_plan][1]
        #print("bs wealt: ",bs_wealth)
        #print("bs gratitude: ", bs_gratitude)
        T_wealth = principle_wealth - bs_wealth
        T_gratitude = principle_gratitude - bs_gratitude
        distance = math.sqrt(T_wealth**2 + T_gratitude**2)
        #print("distance: ", distance)
        d_normalized = distance / math.sqrt(2)
        Integrity = 1-d_normalized
        if Integrity<self.integrity_threshold:
             Integrity_sur = 0
        else: Integrity_sur = Integrity-self.integrity_threshold
        print("Integrity: ", Integrity_sur)
        return Integrity_sur

    def default_strategy(self,benevolence_wealth,benevolence_gratitude):
        expected_sum=[]
        for i in range(7):
          benev=self.benevolence_calculation(benevolence_wealth,benevolence_gratitude,i)

          #print(benev)
          trust_V = []
          integrity = self.integrity_calculation()

          for X in benev:
              if integrity != 0:
                if X==0:
                    trust_V.append(0)
                else:
                   trust_V.append((10*math.sqrt(X**2 + integrity**2 +1*0.2)))
              else: trust_V.append(0)

          #print("trust V")
          #print(trust_V)

          if sum(trust_V)==0:
             probabilities =[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          else: probabilities=self.softmax(trust_V)
          #print("probabilities: ", probabilities)
          expected = []
          for count in range(len(probabilities)):
              expected.append(float(count*probabilities[count]))
          expected_sum.append(sum(expected))


        #print("expected")
        #print(expected)
        #expected_sum = sum(expected)
        #print("expected sum= ",expected_sum)
        utility =[]
        for i in range(len(expected_sum)):
            utility.append(6-i+expected_sum[i])
        for count in range(len(utility)):
            print("expected sum ",utility[count])
        best = np.argmax(utility)

        return best

    def decide(self,benevolence_wealth,benevolence_gratitude):
        """Decide how much to send to B and deduct immediately."""
        if self.strategy is None:
            amt = self.default_strategy(benevolence_wealth,benevolence_gratitude)
        else:

            amt = self.strategy(self)



        amt = max(0, min(int(amt), self.money))
        self.amount_sent = amt
        self.money -= self.amount_sent


class PlayerB(Agent):
    def __init__(self, unique_id, model, strategy=None):
        super().__init__(model)
        self.unique_id = unique_id

        self.amount_received = 0
        self.amount_returned = 0
        self.strategy = strategy

    def default_strategy(self):
        # Example default: return 50% of received amount
        return int(self.amount_received * 0.5)

    def decide(self):
        """Compute received (tripled) and decide how much to return."""
        self.amount_received = self.model.player_a.amount_sent * 3

        if self.strategy is None:
            amt = self.default_strategy()
        else:
            # user-provided strategy should be callable(agent)
            amt = self.strategy(self)

        amt = max(0, min(int(amt), self.amount_received))
        self.amount_returned = amt


class TrustGameModel(Model):
    def __init__(self, strategy_a=None, strategy_b=None):
        super().__init__()
        # you can pass custom strategies (callables) when creating the model
        self.player_a = PlayerA(unique_id=1, model=self, strategy=strategy_a)
        self.player_b = PlayerB(unique_id=2, model=self, strategy=strategy_b)

    def step(self,benevolence_wealth,benevolence_gratitude):
        # Phase 1: A decides
        self.player_a.decide(benevolence_wealth,benevolence_gratitude)
        # Phase 2: B decides (depends on A)
        self.player_b.decide()
        # Phase 3: payoff update
        self.player_a.money += self.player_b.amount_returned
        # B keeps remainder

    def results(self):
        return {
            "A_sent": self.player_a.amount_sent,
            "B_received_tripled": self.player_b.amount_received,
            "B_returned": self.player_b.amount_returned,
            "A_final_money": self.player_a.money,
            "B_final_money": self.player_b.amount_received - self.player_b.amount_returned
        }
    def result(self):
        return self.player_a.amount_sent

if __name__ == "__main__":

    output = np.zeros((11,11))
    for iteration in range(11):
      for iter in range(11):
        model_default = TrustGameModel()
        model_default.step(iteration/10,iter/10)
        print("Iteration: ", iteration/10, "iter: ", iter/10, "Strategies:", model_default.results())
        output[iteration][iter] = model_default.result()
    print(output)
    plt.figure(figsize=(6, 5))

    # Plot matrix
    plt.imshow(output, cmap='viridis', interpolation='nearest')

    #  color mapping
    plt.colorbar(label="Value")

    # Add labels
    plt.title("Decision of a trustor")
    #plt.xlabel("Benevolence for gratitude")
    plt.xlabel("Benevolence for laziness")
    plt.ylabel("Benevolence for wealth")

    # Show the numeric values inside squares (optional)

    for i in range(output.shape[0]):
        for j in range(output.shape[1]):
            plt.text(j, i, output[i, j], ha='center', va='center', color='white')

    plt.show()


    # Create model with custom strategies:
    #model_custom = TrustGameModel(strategy_a=cautious_a, strategy_b=generous_b)
    #model_custom.step()
    #print("Custom strategies:", model_custom.results())